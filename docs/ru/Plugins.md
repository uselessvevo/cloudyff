## Plugin

Плагины в **Pie-Audio** -- это конструктор. Если вам чего-то не достаёт, то возьмите различные классы-расширения, утилиты и т.д. и сделайте плагин так, как вам хочется. Только не наглейте.

В архитектуре присутствует такое понятие, как **Plugin-Mixins-Registry**, что подразумевает под собой использование 
следующей парадигмы проектирования плагинов, состоящий из трёх компонентов:
* Плагин
* Класс-расширение
* Реестр

## Часть 1 - Плагины. 

### 1.1. Определение

Плагин - это программа (_компонент_), расширяющий функционал основной программы и остальных плагинов.

### 1.2. Типы плагинов

1. Обычный плагин - это самостоятельная программа (открывающаяся в отдельном окне), дающая пользователю 
взаимодействовать с медиа-файлами, обращаться в сеть-интернет, менять конфигурацию основного приложения и т.д.

2. Плагин-расширение основных компонентов (плагинов). Такой плагин позволяет расширить функционал 
других плагинов-компонентов. К примеру, это может быть расширение для плагина `Preferences` (Настройки) - `Appearance`.
Данный плагин добавляет страницу настроек в список настроек.

**[Предложение - переименовать `menuman`, `toolbarman` в `menupref`, `toolbarpref`. Или как-то иначе обозначить принадлежность к настройка]**

### 1.3. Устройство класса PiePlugin

Архитектура класса максимально проста и понятна. Она делится на основные части:

1. Классовые атрибуты

    1.1. Основные атрибуты
     * name - наименование плагина
     * type - тип плагина (не реализовано использование)
     * requires - список наименования обязательных плагинов от которых зависит плагин
     * optional - список наименования необязательных плагинов от которых зависит плагин
     * widget_class - класс виджета
    
    1.2. Сигналы реестра плагинов (PluginRegistry):
     * sig_reg_plugins_ready - все плагины запущены (инициализированы)
     * sig_reg_plugins_teardown - все плагины завершили работу
    
    1.3. Сигналы плагина
     * sig_plugin_ready - плагин запущен (инициализирован)
     * sig_plugin_loading - плагин грузится (не реализован; упразднить)
     * sig_plugin_teardown - плагин завершил работу
     * sig_plugin_reloading - плагин перезагружается (не реализовано)
     * sig_exception_occurred - плагин вызывал ошибку (не реализован; не реализовано)
     * sig_before_main_window_visible - до отображения основного окна программы
     * sig_on_main_window_show - основное окно отобразилось (инициализировано)
     * sig_on_main_window_close - основное окно завершило работу


2. Методы подготовки и инициализации класса плагина
   * prepare - подготавливает сигналы и вызывает нижеописанные методы
   * connect_additional_signals - подключает пользовательские сигналы
   * prepare_widget - запускает (инициализирует) класс виджета
   * init - инициализирует плагин
   * call - вызывает плагина (к примеру, при нажатии кнопки вызова окна плагина)

3. Методы получения основных полей, атрибутов и т.д.
   * get_plugin_icon - возвращает иконку плагина (QIcon)
   * get_widget - возвращает экземпляр класса виджета
   * get_name - возвращает человеческое наименование плагина
   * get_title - возвращает человеческий заголовок плагина
   * get_description - возвращает человеческое описание плагина

6. Событийные методы (привязаны к сигналам)
5. Встроенные в python magic-методы (используются для отладки)

### 1.4. Структура директории

Все плагины делятся на два типа: встроенные и сторонние. 
Встроенные располагаются в директории **pieapp/plugins** и запускаются первыми, сторонние в **%HOME%/.pie/plugins**.

Директория содержит в себе основные файлы и директории:
* assets - необязательная директория с темой оформления, иконками и прочими статичными файлами.
* widgets - необязательная директория с виджетами (компонентами) плагина
* plugin.py - основной модуль с классом плагина
* mainwidget.py - обязательный, если плагин является графическим, модуль; содержит в себе лишь графическую часть плагина
* confpage.py - необязательный модуль с классом страницы настроек (ConfigPage)


### 1.5. Структура модуля plugin.py

Модуль плагина делится на три основные части:

1. Импортирование модулей:
   * Встроенные в Python (_os, sys, pathlib и т.д._)
   * Сторонние модули (_PySide6, watchdog и т.д._)
   * Модули **Pie-Audio** (pieapp.api.utils, pieapp.widgets.buttons)
   * Локальные. Импортируется без указания всего пути до модуля
2. Класс плагина
3. Метод **main**, который возвращает экземпляр класса плагина. 
   Так же позволяет настроить плагин перед его инициализацией в реестре плагинов.


## Часть 2. Класс-расширение

### 2.1. Определение

Класс-расширение - это класс, расширяющий функционал наследующего его класса.

В **Pie-Audio** такие классы, зачастую, представляют собой набор методов, дающие более упрощённый способ доступа к реестру,
а также позволяющий создавать объекты графического интерфейса и добавляющий их в реестр из одного метода.

К примеру, **ConfigAccessorMixin** предоставляет методы обращения к встроенной и конфигурации пользователя. 
А класс **ToolBarAccessorMixin** даёт возможность создать и получить графический элемент, а так же 
добавить его на панель с вкладками и в реестр **ToolBarRegistry**.

Так же стоит отметить, что большая часть таких классов используют атрибут плагина - name.


## Часть 3. Реестры

### 3.1. Определение

Реестр - класс-контейнер, содержащий в себе данные того или иного вида. Будь то конфигурация, графические 
объекты или снимки состояния файлов.

### 3.2. Структура


Все классы-реестры наследуются от **BaseRegistry** и обязаны иметь классовый атрибут - name, используемый в **RegistryContainer**.

**[Предлагаю упразднить большую часть методов, относящиеся к получению и обновлению данных, т.к. опыт со SnapshotRegistry показал, что эта парадигма с BaseRegistry не нужна]**
